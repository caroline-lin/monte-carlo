\documentclass{beamer}
\newcommand\di\partial
\newcommand\pars[1]{\left(#1\right)}
\newcommand\mat[1]{#1}
\usepackage{amsmath,amssymb,amsthm,bbm,bm, amsfonts}
\usepackage{algorithm}
\usepackage{algpseudocode}
\setbeamertemplate{footline}[frame number]
\begin{document}
% Slide Outline:
% Laplace's Problem
% Poisson's Problem (A Generalization)
% Possible Approaches (Finite Whatever)
\begin{frame}{Finite Differences}
One common approach: solve using the 2D discrete Laplacian.
	\[ L = \frac{1}{h^2} \begin{bmatrix} 
		0 & 1 & 0 \
		1 & -4& 1 \
		0 & 1 & 0 
	\end{bmatrix} \]
Pros: solving becomes a matrix solve
Boundary conditions are encoded into a vector
Cons: Needs a Cartesian grid

Alternatives: Finite elements, finite volumes.
\end{frame}
% Random Walks
\begin{frame}{Random Walks in a nutshell}
A "normally distributed" stochastic process in time, i.e.
	
$E(B(t)) \sim N(0, t)$ for all times $t \geq 0$
\end{frame}

\begin{frame}{Laplace's Equation with Random Walks}
Ito's formula:
$u(x) = E^x[ g(\mathbf{B}(T))] + \frac{1}{2} E^x \left[ \int_0^T f(B(s))ds \right]$ {#eq:rw}

For Laplace's, take the mean over the boundary values, weighted by frequency of random walks.
\end{frame}
% Why It Works (In Theory)

% Extensions: Interior Finite Differences

% Extensions: Self-Contacting Boundary Coupling

% Extensions: Walk On Spheres
% Results: Accuracy
% Results: Spiky Domains
% Results: Runtime
% Conclusions
\begin{frame}{Laplace's Problem}
\begin{itemize}
\item We wish to solve \emph{Laplace's Problem}.
Here, we have some closed domain $\Omega$ with a boundary $\di\Omega$.
We are given a function $g\pars{\vec{x}}$, defined on $\vec{x}\in\di\Omega$.
\item We wish to find a function $u\pars{\vec{x}}$, defined on $\Omega$,
such that $\Delta u=0$ on $\Omega$
and such that $u\pars{\vec{x}}=g\pars{\vec{x}}$ on $\di\Omega$.
\item A generalization to this is \emph{Poisson's Problem},
wherein we also have some $f\pars{\vec{x}}$ defined on $\vec{x}\in\Omega$,
and where we require that $\Delta u\pars{\vec{x}}=f\pars{\vec{x}}$ on $\Omega$.
\end{itemize}
\end{frame}

\begin{frame}{Extension: Interior Finite Differences}
\begin{itemize}
\item However, using only random walks can be very slow and inefficient.
Having to do many random walks for each point we can about can be very slow.
\item Instead, we can combine methods.
Let us define a Cartesian grid on the inside of our boundary,
as large as possible.
Now, if we knew the boundary values on this Cartesian grid,
we'd be able to run a finite differences scheme
and solve the problem at every point we care about.
\item And to find the values on the boundary of the Cartesian grid,
we can use the random walks.
Now, the amount of random walks we need to do scales with $h^{-1}$,
instead of $h^{-2}$ as it was earlier.
This saves us a lot of work.
\end{itemize}
\end{frame}

\begin{frame}{Extensions: Self-Contacting Boundary Coupling}
\begin{itemize}
\item To further improve this,
we can introduce coupling between the grid points.
If a random walk touches the boundary of the Cartesian grid,
then we can stop the random walk early,
and instead just add a \emph{coupling} term.
\item This coupling term relates the fact that certain random walks
touched another boundary point, so the expected value of that random walk
should be the expected value of a random walk from this boundary point.
\item We thus need to solve an implicit formula
to find the values on the grid boundary.
If $\mat{F}$ is a coupling matrix,
with $F_{i,j}$ begin the number of random walks
starting at boundary point $i$ and ending at boundary point $j$,
then we wish to solve
$$\vec{u}=\frac{1}{K}\mat{F}\vec{u}+\frac{1}{K}\vec{b},$$
where $\vec{b}$ is a vector of total values obtained via random walks,
and $K$ is the number of random walks performed.
\end{itemize}
\end{frame}
\end{document}
